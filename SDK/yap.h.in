/*!
 * @file yap.h
 * @author undisassemble
 * @brief SDK header
 * @details Two files are required to use the SDK: `yap.h` and `yap.dll`, make sure that `__YAP_VERSION__` matches the packer. You must link to `yap.dll` directly, so that it appears in the applications import directory. After protection, `yap.dll` is unlinked, meaning you don't need to (and shouldn't) distribute `yap.dll` along with your application. Because `yap.dll` is never actually loaded, you cannot find `yap.dll` with `GetModuleHandle` and cannot find SDK functions with `GetProcAddress`.
 * @warning Do not rename `yap.dll`, renaming it prevents the SDK from being recognized.
 * @version 0.0.0
 * @date 2025-04-08
 * @copyright MIT License
 */

// PLEASE READ ME!
// 
// Functions provided in this header and in yap.dll DO NOT DO ANYTHING UNLESS YOUR APPLICATION HAS BEEN PACKED!
// Every function is handled internally by the packer, meaning you do not need to distribute yap.dll with your application, because it doesn't do anything.
// Please make sure that you link with yap.dll specifically, and do not rename it, otherwise the packer will not be able to resolve the imports!
// All functions are provided if they were imported, regardless of configuration options when packing.
// You also cannot use GetProcAddress to get access to these functions.
// 
// You don't have to link with yap.dll if you only use reasm macros.
// 
// Have a good day :)

#pragma once

#ifndef _WIN64
#error YAP can only be used on 64-bit Windows binaries!
#endif

#define WIN32_LEAN_AND_MEAN
#include <windows.h>

#define __YAP_VERSION__ "@PROJECT_VERSION@"


#ifdef __cplusplus
extern "C" {
#else
#include <stdbool.h>
#endif

/*!
 * @brief Check for attached debuggers.
 * @details It is highly recommended that you use this in your main thread, as no protective threads are spawned by the packer.
 * @note Only the main thread of the application can check for hardware breakpoints.
 *
 * @return true Debugger present.
 * @return false No debugger present.
 */
__declspec(dllimport) bool __stdcall CheckForDebuggers();

/*!
 * @brief Retrieves the base address of the running executable.
 * @note If using anti-dump, GetModuleHandle(NULL) will return NULL, use this instead.
 * 
 * @return HMODULE Handle to self.
 */
__declspec(dllimport) HMODULE __stdcall GetSelf();

#ifdef __cplusplus
}
#endif


// Asm macros
#define YAP_OP_REASM_MUTATION 0b10000000
#define YAP_OP_REASM_SUB      0b00000010
#ifdef __MINGW64__
#define YAP_OP(x) __asm__ volatile (".byte 0x67, 0x48, 0x0F, 0x1F, 0x04, 0x25, %c0, 0x80, 0x65, 0x89" : : "i" ((x) & 0xFF))
#else
#define YAP_OP(x) __asm nop qword [0x89658000 | ((x) & 0xFF)]
#endif

/*!
 * @brief Changes the reassemblers mutation setting.
 * @warning This is all linear, any control flow changes/optimizations might change how you expect this to behave!
 */
#define YAP_MUTATIONLEVEL(level) YAP_OP(YAP_OP_REASM_MUTATION | (level & 0b1111111))

/*!
 * @brief Changes the reassemblers substitution setting.
 * @warning This is all linear, any control flow changes/optimizations might change how you expect this to behave!
 */
#define YAP_SUBSTITUTION(enabled) YAP_OP(YAP_OP_REASM_SUB | (enabled & 1))
